<!DOCTYPE html>

<title>Graph Cards</title>

<body>

<link rel="stylesheet" type="text/css" href="../css/view.css">
<!-- Dynamic Links 
<script src="http://bl.ocks.org/syntagmatic/raw/3341641/render-queue.js"></script>
<script src="http://d3js.org/d3.v2.js"></script>
<script src="http://code.jquery.com/jquery-1.11.2.min.js"></script>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.2/themes/smoothness/jquery-ui.css">
<script src="http://code.jquery.com/ui/1.11.2/jquery-ui.js"></script>
-->
<script src="../js/d3.v2.js"></script>
<script src="../js/renderQueue.js"></script>
<script src="../js/jquery-1.11.2.min.js"></script>
<script src="../js/jquery-ui.min.js"></script>

<link rel="stylesheet" href="../css/jquery-ui.css">

<script src="../js/jquery.flip.min.js"></script>

<!-- Library for plot display -->
<script src="../js/jquery.flot.js"></script>

<!-- Library for UnionFind DataStructure -->
<script src="../js/union-find.js"></script>

<!-- Custom stylesheet for flipping cards -->
<link rel="stylesheet" type="text/css" href="../css/FrameStyle.css">

<div id="mainTitle">
<center><b>Graph Cards</b></center>
</div>

<!-- Central Container to center statistics, canvas and control panel -->
<div id="upperContainer" class="centralCont">

<!-- Panel containing statistical measures and charts -->
<div id="stats" class="sidePanel">
<p id="numNodes">Number of vertices: </p>
<p id="numEdges">Number of egdes: </p>
<p id="graphStats"></p>
<p> ... </p>
<center><b>Edges and Vertices visible</b></center>
<div id="freqPlot" class="plot"></div>
</div>

<!-- Panel containing the central graph for display -->
<div id="mainGraph"></div>

<!-- Panel containing the controls and filtering mechanisms -->
<div id="controls" class="sidePanel">
<button id="resetSlider">Reset Slider</button>
<button id="resetMainGraph">Reset Main Graph</button>
<button id="screenShot">Take Screen Shot</button>
<p/>
<div id="slider"></div>
<p/>
<center><b>Density Measure</b></center>
<div id="occPlot" class="plot"></div>
<p/>
<center><b>Algorithms</b></center>
<button id="maxTree">Maximum Spanning Tree (Static)</button>
<button id="maxTreeFDL">Maximum Spanning Tree (Force Directed Layout)</button>
</div>

</div> <!-- End of upper container -->

<div class="buffer"></div>

<div id="midContainer" class="midCont">
<select>
  <option>Filter1</option>
  <option>Filter2</option>
</select>
</div>



<!-- Center binder container for lower divs -->
<div id="lowerCont" class="centralCont">

<div id="sideView" class="secondCanvas"></div>

<!-- Panel containing the cards -->
<div id="cardView" class="cardPanel">
<center id="relatedTitle"><b>Related Cards<b></center>

<div id="cardOne" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardOneFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardOneBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>

<div id="cardTwo" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardTwoFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardTwoBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>


<div id="cardThree" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardThreeFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardThreeBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>


<div id="cardFour" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardFourFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardFourBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>


<div id="cardFive" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardFiveFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardFiveBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>


<div id="cardSix" class="card">
<div class="f1_container">
<div class="f1_card" >
  <div id="cardSixFace" class="front face">
   <p>Crossing: 016481T</p>
   <p>Date: 11/06/14</p>
   <p>State ID: 48</p>
   <p>City: 5300</p>
   <p>Lat: 364057224</p>
   <p>Long: 1007924176</p>
  </div>
  <div id="cardSixBack" class="back face center">
    <p>Railroad: SW</p>
	<p>Highway: ST 0000</p>
	<p>Street: PERRYTON</p>
	<p>Crossing Type: 3</p>
	<p>Maximum Train Speed: 20</p>
	<p>Maximum Car Speed: 20</p>
  </div>
</div>
</div>
</div>

</div>

</div>

<script>
var WIDTH = $('#mainGraph').width();
var HEIGHT = $('#mainGraph').height();

var NUM_NODES = 25;
var NUM_EDGES = 100;

/* Variables for the time varying density plots */
var renderStamp = 0;
var veStamp = 0;
var dPlot;
var vePlot;
var updateInterval = 5;

/* List of plotted desity data points */
var densityData = [];

/* List of visible edges and vertices */
var vData = [];
var eData = [];

/* Global varible used to denote if the user is exploring data by pinning verticies 
 * to the view. If this is the case, we will not render on mousemouse events
 */
var graphPinned = false;
var pinnedStack = [];

var links = [];
var nodes = [];

var x = d3.scale.linear()
        .domain([0, WIDTH])
        .range([0, WIDTH]);

var y = d3.scale.linear()
          .domain([0, HEIGHT])
          .range([HEIGHT, 0]);

var cv = d3.select("#mainGraph")
             .append("canvas")
             .attr("id", "canvas")
             .attr("width", WIDTH)
             .attr("height", HEIGHT);

var canvas = cv
            .call(d3.behavior.zoom().x(x).y(y).scaleExtent([1,12]).on("zoom", zoom))
             .node()
             .getContext("2d");

var getColor = d3.scale.linear()
               .domain([0, 0.5, 1])
               .range(["#ef2212", "#e7c767", "#2799df"])
               .interpolate(d3.interpolateHcl); 

function generateCards(num) {
	var cards = d3.range(num).map(function(d, i) {
		return {
			name: Math.random().toString(36)
		};
	});

	return cards;
};

function generateNodes(num) {
   var nodes = d3.range(num).map(function(d, i) {
     return {
       x: Math.random() * WIDTH,
       y: Math.random() * HEIGHT,
       r: Math.random() * 10 + 3,
       value: Math.random() * 10, 
       id: i,
       color: getColor(Math.random()),
       label: 'Hello World!', 
       neighbors: [],
       visible: true,
       pinned: false,
       type: "node"
     };
   });

  return nodes;
};

function generateLinks(nodes, num) {
   var links = d3.range(num).map(function(d) {
       return {
         source: nodes[Math.floor(Math.random() * nodes.length)],
         target: nodes[Math.floor(Math.random() * nodes.length)],
         color: getColor(Math.random()),
         value: Math.random(),
         visible: true,
         type: "link"
       };
   });
   
   setNeighbors(links);
   return links;
};

function setNeighbors(links) {
  for(i = 0; i < links.length; i++) {
    var l = links[i];
    var n1 = l.source;
    var n2 = l.target;

    n1.neighbors.push(n2);
    n2.neighbors.push(n1);
  }
};

var clear_canvas = function() {
    canvas.clearRect(0,0,WIDTH, HEIGHT);
};

function renderNode(d) {
  if(graphPinned) {
    if(!d.pinned) {
      return;
    }
  }

  if(!d.visible) {
    return;
  } 

  var cx = x(d.x);
  var cy = y(d.y);

  canvas.fillStyle = d.color;
  canvas.beginPath();
  canvas.fillRect(cx, cy, d.r / 2, d.r / 2);
  canvas.stroke();
  canvas.fill();
};

function renderEdge(e) {
  if(graphPinned) {
    if(e.source.pinned === false || e.target.pinned === false) {
      return;
    }
  }

  if(!e.visible) {
    return;
  }

  if(e.source.visible === false || e.target.visible === false) {
    return;
  }

  var cx = x(e.source.x);
  var cy = y(e.source.y);

  var dx = x(e.target.x);
  var dy = y(e.target.y);

   canvas.strokeStyle = e.color;
   canvas.beginPath();
   canvas.moveTo(cx, cy);
   canvas.lineTo(dx, dy);
   canvas.stroke();
   canvas.fill();
   
};

function renderData(o) {
  if(o.type === "node") {
    renderNode(o);
  } else
  if(o.type === "link") {
    renderEdge(o);
  } else {
    console.log("Error!");
  }
};

function FDL(nodesArr, linksArr) {
  var force = d3.layout.force()
              .charge(-40)
              .linkDistance(5)
              .gravity(0.06)
              .size([WIDTH, HEIGHT]);

       force.nodes(nodesArr)
            .links(linksArr);
      
       force.start();
       for(i = 0; i < 10; i++) force.tick();
       force.stop();
        
       return nodesArr.concat(linksArr);
};

/* Sets the render queue for the canvas */
var render = renderQueue(renderData).clear(clear_canvas);

/* Generates the random nodes and edges for the graph */
var nodes = generateNodes(NUM_NODES);
var links = generateLinks(nodes, NUM_EDGES);

/* Runs D3's Force Directed Layout algorithm */
var data = FDL(nodes, links);

/* Renders the data via render queue */
render(data);
setSlider(nodes);

/* Sets the various stats in the statistics panel */
setVertexStats(nodes.length);
setEdgeStats(links.length);
setGraphStats(nodes, links);

/* Sets the interactive plots */
initDensityPlot();
initVEPlot();

/* Mouse motion listener for node mouse over events in the canvas */
/* For zoom-in, coordiates are being translated via objects x and y */
/* To determine correct position, apply x and y to the marked coordiantes */
/* i.e. x(d.x) and y(d.y) for node d */

/* Boolean to determine if we are currently hovering over a node */
var onNode = false;

cv.on("mousemove", function() {
  var evt = d3.mouse(this);
  
  /* Boolean  changed to show if we have recently moused over a node */
  var localOnNode = false;

  /* Temporary variable for the previous state of onNode */
  var currentOnNode = onNode;

  var thresHold = 3;
  var examine = true;
  for(i = 0; i < nodes.length; i++) {
    var d = nodes[i];
    d.visible = false;

    /* If we are in 'pinning' mode, i.e. the user has clicked on a node */
    /* We don't want to re-render on mouse movement of invisible non pinned nodes */
    var skip = false;
    if(graphPinned) {
      if(!d.pinned) {
        skip = true;
      }
    }


  if(!skip) {
    /* If the mouse cursor is within radius, highlight the the node and it's neighbors */
    if(withInRadius(d, evt[0], evt[1], x, y, thresHold)) {
      localOnNode = true;
      d.visible = true;
      console.log(d);
      nodeCallBack(d);
      showLabel(canvas, d, x, y);
    
      for(j = 0; j < d.neighbors.length; j++) {
        var k = d.neighbors[j];
        showLabel(canvas, k, x, y);
        k.visible = true;
        k.pinned = true;
      }

     /* We loop over the remaining nodes, marking 
      * non-neighbors as non-visible 
      */
      i++;
      while(i < nodes.length) {
        var m = nodes[i];

        if(!inArr(d.neighbors, m)) {
          m.visible = false;
        }

        i++;
      }

        /* After we have moused over a node, we can break for this loop */
        break;

      }
    }
  }

    /* If we mouse out, mark all nodes visible */
    onNode = localOnNode;
    if(!onNode) {
      for(i = 0; i < nodes.length; i++) {
        n = nodes[i];
        n.visible = true;
      }
    }

    /* If the value of onNode has changed from this function all */
    /* Call a render, else dont waste the effort */
    if(currentOnNode !== onNode) {
      render(data);
    }

});


/* Click listener for mouse clicking events */
cv.on("click", function() {
  var evt = d3.mouse(this);
  var thresHold = 3;

  for(var i = 0; i < nodes.length; i++) {
    var d = nodes[i];

    /* If the translated coordinates are within a a circular radius of the click event */
    if(withInRadius(d, evt[0], evt[1], x, y, thresHold)) {
      graphPinned = true;
      d.pinned = true;
      d.visible = true;
      pinnedStack.push(d);

      for(var j = 0; j < d.neighbors.length; j++) {
        var n = d.neighbors[j];
        n.pinned = true;
        n.visible = true;
      }

      break;
    }
  }
});

function withInRadius(node, xc, yc, xTransform, yTransform, threshHold) {
  return (Math.abs((xTransform(node.x)  + node.r) - xc) < threshHold && Math.abs((yTransform(node.y) + node.r) - yc) < threshHold);
};

function cloneGraph(nodesArr) {
  var ns = [];
  var es = [];

  for(var i = 0; i < nodesArr.length; i++) {
    var newNode = nodeClone(nodesArr[i]);
    ns.push(newNode);
  }

  for(var k = 0; k < links.length; k++) {
    for(var n = 0; n < ns.length; n++) {
      for(var m = 0; m < ns.length; m++) {
        var edge = links[k];
        var node1 = ns[n];
        var node2 = ns[m];

        var clone = null;

        if(edge.source.id === node1.id && edge.target.id === node2.id
          || edge.source.id === node2.id && edge.target.id === node1.id) {
          clone = edgeClone(edge, node1, node2);
        } 

        if(clone !== null) {
          es.push(clone);
        }

      }
    }
  }

  return [ns, es];
};



var svg = null;
//Note this will be a little hacky due to time limits 
function nodeCallBack(node) {
  $('#sideView').html('');
  //Do Node callback stuffs here
  //Create induced subgraph from node and neighbors passed, 
  //show in side view

  $('#sideView').append("<p> Induced Subgraph for node: " + node.id + "</p>");

  var w = $('#sideView').width();
  var h = $('#sideView').height();

  var nodesArr = [];
  for(var j = 0; j < node.neighbors.length; j++) {
    nodesArr.push(node.neighbors[j]);
  }

  var grph = cloneGraph(nodesArr);

  var ns = grph[0];
  var es = grph[1];

  renderSideView(ns, es, w, h);

};

function renderSideView(ns, es, w, h) {

svg = d3.select('#sideView')
          .append('svg')
          .attr('id', 'svg')
          .attr('width', w)
          .attr('height', h)
          .append('g')
          .call(d3.behavior.zoom().scaleExtent([1, 8]).on("zoom", svgZoom));

    svg.append('rect')
        .attr("class", "overlay")
        .attr("width", w)
        .attr("height", h)
        .style("fill", "white");

   var force = d3.layout.force()
                .charge(-120)
                .linkDistance(30)
                .gravity(0.6)
                .size([w, h]);

    force.nodes(ns)
         .links(es)
         .start();

    var no = svg.selectAll(".node")
          .data(ns).enter()
          .append("circle")
          .attr("class", "node")
          .attr("r", function(d) { return d.r; })
          .attr("transform", function(d) { return "translate(" + d + ")"; })
          .style("fill", function(d) { return d.color; })
          .call(force.drag);

      var ls = svg.selectAll(".link")
          .data(es).enter()
          .append("line")
          .attr("class", "link")
          .style("stroke", function(e) { return e.color; })
          .style("stroke-width", 0.5);

          force.on("tick", function() {
            ls.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

            no.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
          });
};


function svgZoom() {
   svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
};

function nodeClone(node) {
  var clone = {};
  
  clone.x = node.x;
  clone.y = node.y;
  clone.r = node.r;
  clone.value = node.value;
  clone.id = node.id;
  clone.label = node.label;
  clone.color = node.color;
  clone.visible = node.visible;
  clone.pinned = node.pinned;
  clone.type = node.type;

  return clone;
};

function edgeClone(edge, n, m) {
  var clone = {};

  clone.target = n;
  clone.source = m;
  clone.color = edge.color;
  clone.value = edge.value;
  clone.visible = edge.visible;
  clone.type = edge.type;

  return clone;
};

function showLabel(canv, node, xTransform, yTransform) {
  canv.fillText(node.label, xTransform(node.x), yTransform(node.y));
};

function inArr(arr, obj) {
  for(var i = 0; i < arr.length; i++) {
    if(arr[i] === obj) {
      return true;
    }
  }
  return false;
};

/* Translation occurs during canvas rendering. */
function zoom() {
  render(data);
};

function getMax(nodesArr) {
  var max = 0;

  for(i = 0; i < nodesArr.length; i++) {
    if(nodesArr[i].value > max) {
      max = nodesArr[i].value;
    }
  }

  return max;
};

function setSlider(nodesArr) {
  var maxVal = getMax(nodesArr);

  $("#slider").slider({
    range: true,
    min: 0, 
    max: maxVal,
    values: [0, maxVal],
    slide: function(event, ui) {
      var low, high;
      low = ui.values[0];
      high = ui.values[1];

      for(i = 0; i < nodes.length; i++) {
        var node = nodesArr[i];
        if(node.value >= low && node.value <= high) {
          node.visible = true;
        } else {
          node.visible = false;
        }
      }
      render(data);
    }
  });
};

function resetVisibility(nodesArr) {
  graphPinned = false;
  for(i = 0; i < nodesArr.length; i++) {
    nodesArr[i].visible = true;
    nodesArr[i].pinned = false;
  }
  render(data);
};

/* Button Listeners */
$("#resetMainGraph").on("click", function() {
  resetVisibility(nodes);
});

$("#screenShot").on("click", function() {
  //TODO Screenshots 
});

$("#maxTreeFDL").on("click", function() {
  showMaxTreeFDL(nodes, links);
});

/* formsCycle method is currently not working
  (sometimes infinite looping). Thus we comment out the max tree function
*/
$("#maxTree").on("click", function() {
  showMaxTree(nodes, links);
});

function showMaxTree(nodesArr, linksArr) {
  linksArr.sort(function(a, b) {
    return a.value - b.value;
  });

  var unionFind = new UnionFind(nodesArr);
  for(var i = 0; i < linksArr.length; i++) {
    var e = linksArr[i];

    e.visible = false;
  }

  for(var j = 0; j < linksArr.length; j++) {
    var e = linksArr[j];

    if(!unionFind.inSameGroup(e.source.id, e.target.id)) {
      e.visible = true;
      unionFind.union(e.source.id, e.target.id);
    }
  }

  render(data);
};

function showMaxTreeFDL(nodesArr, linksArr) {
  linksArr.sort(function(a, b) {
    return a.value - b.value;
  });

  var unionFind = new UnionFind(nodesArr);
  var edgesToCopy = [];

  var copiedEdges = [];
  var copiedNodes = [];

  var w = $('#sideView').width();
  var h = $('#sideView').height();

  for(var j = 0; j < linksArr.length; j++) {
    var e = linksArr[j];

    if(!unionFind.inSameGroup(e.source.id, e.target.id)) {
      edgesToCopy.push(e);
      unionFind.union(e.source.id, e.target.id);
    }
  }

  for(var i = 0; i < edgesToCopy.length; i++) {
    var e = edgesToCopy[i];

    var cOne = nodeClone(e.source);
    var cTwo = nodeClone(e.target);

    var edge = edgeClone(e, cOne, cTwo);


    if(!nodeInArr(copiedNodes, cOne)) {
      copiedNodes.push(cOne);
    }

    if(!nodeInArr(copiedNodes, cTwo)) {
      copiedNodes.push(cTwo);
    }

    copiedEdges.push(edge);
  }

  renderSideView(copiedNodes, copiedEdges, w, h);

};

function nodeInArr(nodesArr, node) {
  for(var i = 0; i < nodesArr.length; i++) {
    if(nodesArr[i].id === node.id) {
      return true;
    }
  }

  return false;
}

function setVertexStats(numNodes) {
	$('#numNodes').html('Number of nodes ' + numNodes);
};

function setEdgeStats(numEdges) {
	$('#numEdges').html('Number of edges ' + numEdges);
};

function getAverageWeight(arr) {
	var sum = 0;

	for(i = 0; i < arr.length; i++) {
		sum += arr[i].value;
	}

	return sum / arr.length;
};

function setGraphStats(nodesArr, linksArr) {
	//Average degree of main graph 
	var avgDeg = linksArr.length / nodesArr.length;

	//Average edge weight
	var avgEWeight = getAverageWeight(linksArr);

	$("#graphStats").html('<p>Average Degree ' + avgDeg + '</p>' +
		'<p>Average Edge Weight ' + avgEWeight + '</p>');
};

function initPlot(plotStr, data) {

  var plot = $.plot("#" + plotStr, [data]);
  return plot;

};

function initDensityPlot() {
  if(dPlot == null) {
    densityData.push([renderStamp, getVisibleDensity(nodes, links)]);
    renderStamp++;
    dPlot = initPlot('occPlot', densityData);
    updateDensityPlot();
  } else {
    console.log("Density plot already initalized");
  }
};

function updateDensityPlot() {
  densityData.push([renderStamp, getVisibleDensity(nodes, links)]);
  renderStamp++;
  dPlot.setData([densityData]);
  dPlot.setupGrid();
  dPlot.draw();

  setTimeout(updateDensityPlot, updateInterval);
};

function initVEPlot() {
  if(vePlot == null) {
    var countArr = getVisibleCount(nodes, links);
    vData.push([veStamp, countArr[0]]);
    eData.push([veStamp, countArr[1]]);
    veStamp++;
    vePlot = initPlot('freqPlot', vData, eData);
    updateVEPlot();
  } else {
    console.log("VE Plot already initalized");
  }

};

function updateVEPlot() {
  var countArr = getVisibleCount(nodes, links);
  vData.push([veStamp, countArr[0]]);
  eData.push([veStamp, countArr[1]]);
  veStamp++;
  vePlot.setData([vData, eData]);
  vePlot.setupGrid();
  vePlot.draw();

  setTimeout(updateVEPlot, updateInterval);
};

function getVisibleCount(nodes, edges) {
  var nCount = 0, eCount = 0;

  for(i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if(node.visible) {
      nCount++;
    }
  }

  for(j = 0; j < edges.length; j++) {
    var edge = edges[j];
    if(edge.source.visible && edge.target.visible) {
      eCount++;
    }

  }

  return [nCount, eCount];
};

function getVisibleDensity(nodes, edges) {
  var countArr = getVisibleCount(nodes, edges);
  var nCount = countArr[0];
  var eCount = countArr[1];

  if(eCount == 0) {
    return 0;
  }

  return nCount / eCount;
}; 



</script>


</body>